<!-- File: blocks/block4-scaling.html -->
<section id="block4" class="survey-block">
  <h2>Rate The Novelty</h2>
  <p class="prompt">
    You will now see <strong>8</strong> short vignettes. For each vignette:
    <ul>
      <li>Would you consider this metabolite “truly novel”? (<strong>Yes</strong> / <strong>No</strong> / <strong>I don’t know</strong>)</li>
      <li>How confident are you in that judgment? (0 = not confident, 10 = completely sure)</li>
      <li>Rate its “Wow” factor (0 = not impressive, 10 = extremely impressive)</li>
    </ul>
  </p>

  <!-- This DIV is where the script will inject the 8 vignettes -->
  <div id="vignette-container"></div>

  <div class="nav-buttons">
    <button class="prev-btn">Back</button>
    <button class="next-btn">Next</button>
  </div>

  <!-- ───────────────────────────────────────────────────────────────────
       Duplicate‐value checker for the numeric sliders and ranks
       (Not strictly needed here unless you want to ensure unique ranks 
        among Confidence or Wow, but left as a stub if you adapt it)
     ─────────────────────────────────────────────────────────────────── -->
  <script>
    // (Optional) If you ever want to highlight duplicate numeric entries 
    // across the sliders, you can write a function similar to checkDups().
    // For now, we do not enforce cross‐row uniqueness for Confidence or Wow,
    // so this can remain empty or be removed.
    function checkDups() { /* no‐op */ }
  </script>

  <!-- ───────────────────────────────────────────────────────────────────
       SCRIPT: Build & persist the 8 vignette evaluations
     ─────────────────────────────────────────────────────────────────── -->
  <script>
    (function() {
      // ─────────────────────────────────────────────────────────────────────
      // 1) FULL POOL OF VIGNETTES (replace these with your real texts)
      //
      //    Each must have:
      //      - id: unique string
      //      - domain: 'Structural'|'Biosynthetic'|'Functional'|'Evolutionary'
      //      - text: the vignette description
      // ─────────────────────────────────────────────────────────────────────
      const allVignettes = [
        // Structural / Scaffold novelty
        { id: 'S_vig1', domain: 'Structural', text: 'A metabolite bearing a fused tetracyclic core never reported in any bacterial species.' },
        { id: 'S_vig2', domain: 'Structural', text: 'A linear peptide chain containing selenium and boron linkages in its backbone.' },
        { id: 'S_vig3', domain: 'Structural', text: 'A macrocyclic scaffold with an unprecedented 14‐membered ring.' },
        { id: 'S_vig4', domain: 'Structural', text: 'A hybrid scaffold linking two classic alkaloid rings via an ether bridge.' },
        { id: 'S_vig5', domain: 'Structural', text: 'A highly strained bicyclic molecule that spontaneously rearranges under mild conditions.' },

        // Biosynthetic / Catalytic novelty
        { id: 'B_vig1', domain: 'Biosynthetic', text: 'An enzyme with a new fold catalyzing a rearrangement never seen in nature.' },
        { id: 'B_vig2', domain: 'Biosynthetic', text: 'Biosynthesis that uses FAD‐dependent radical chemistry on a sugar moiety.' },
        { id: 'B_vig3', domain: 'Biosynthetic', text: 'Convergent co‐expression of two unrelated pathways to yield a single hybrid product.' },
        { id: 'B_vig4', domain: 'Biosynthetic', text: 'A known oxidase scaffold repurposed to install a nitrile in one step.' },

        // Functional / Phenotypic novelty
        { id: 'F_vig1', domain: 'Functional', text: 'Potent activity against a pathogen with a novel mode of action never reported.' },
        { id: 'F_vig2', domain: 'Functional', text: 'Dual activity as both an anticancer agent and a microbial signaling molecule.' },
        { id: 'F_vig3', domain: 'Functional', text: 'Selective inhibition of a drug‐resistant strain through an unexplored target.' },

        // Evolutionary / Ecological novelty
        { id: 'E_vig1', domain: 'Evolutionary', text: 'Produced only by a deep‐sea fungus previously thought incapable of secondary metabolism.' },
        { id: 'E_vig2', domain: 'Evolutionary', text: 'A known soil metabolite now found in an Antarctic microbe—first marine convergence.' },
        { id: 'E_vig3', domain: 'Evolutionary', text: 'Gene cluster suggests horizontal transfer from a plant lineage into bacteria.' }
      ];

      // ─────────────────────────────────────────────────────────────────────
      // 2) UTILITY: Fisher–Yates shuffle (in‐place)
      // ─────────────────────────────────────────────────────────────────────
      function shuffle(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
      }

      // ─────────────────────────────────────────────────────────────────────
      // 3) PULL DOMAIN RANKS FROM BLOCK 3
      //    window.block3DomainAnswers should be: 
      //       { Structural: "1", Biosynthetic: "2", Functional: "3", Evolutionary: "4" }
      //    If any rank is missing or invalid, treat as rank 4 by default.
      // ─────────────────────────────────────────────────────────────────────
      const domainRanks = window.block3DomainAnswers || {};
      const rankToDomains = { 1: [], 2: [], 3: [], 4: [] };
      ['Structural','Biosynthetic','Functional','Evolutionary'].forEach(dom => {
        const r = parseInt(domainRanks[dom] || '5', 10);
        if (r >= 1 && r <= 4) {
          rankToDomains[r].push(dom);
        } else {
          rankToDomains[4].push(dom);
        }
      });

      // ─────────────────────────────────────────────────────────────────────
      // 4) BUILD OR REUSE window.block4Vignettes (the 8 picks)
      //    Once picked, they stay fixed until a full page refresh.
      // ─────────────────────────────────────────────────────────────────────
      if (!window.block4Vignettes) {
        const picks = [];

        // Helper: pick up to count from domain’s pool
        function pickRandomForDomain(domain, count) {
          const pool = allVignettes.filter(v => v.domain === domain);
          if (pool.length <= count) return pool.slice();
          shuffle(pool);
          return pool.slice(0, count);
        }

        // (A) Rank 1 domains → total of 4 vignettes
        const rank1 = rankToDomains[1];
        if (rank1.length === 1) {
          picks.push(...pickRandomForDomain(rank1[0], 4));
        } else if (rank1.length === 2) {
          picks.push(...pickRandomForDomain(rank1[0], 2));
          picks.push(...pickRandomForDomain(rank1[1], 2));
        } else if (rank1.length >= 3) {
          // give each of first 3 one pick, last pick randomly among them
          const chosen = rank1.slice(); shuffle(chosen);
          picks.push(...pickRandomForDomain(chosen[0], 1));
          picks.push(...pickRandomForDomain(chosen[1], 1));
          picks.push(...pickRandomForDomain(chosen[2], 1));
          picks.push(...pickRandomForDomain(chosen[3 % chosen.length], 1));
        }

        // (B) Rank 2 domains → total of 2 vignettes
        const rank2 = rankToDomains[2];
        if (rank2.length === 1) {
          picks.push(...pickRandomForDomain(rank2[0], 2));
        } else if (rank2.length === 2) {
          picks.push(...pickRandomForDomain(rank2[0], 1));
          picks.push(...pickRandomForDomain(rank2[1], 1));
        } else if (rank2.length >= 3) {
          shuffle(rank2);
          picks.push(...pickRandomForDomain(rank2[0], 1));
          picks.push(...pickRandomForDomain(rank2[1], 1));
        }

        // (C) Rank 3 → pick 1
        const rank3 = rankToDomains[3];
        if (rank3.length >= 1) {
          picks.push(...pickRandomForDomain(rank3[Math.floor(Math.random() * rank3.length)], 1));
        }

        // (D) Rank 4 → pick 1
        const rank4 = rankToDomains[4];
        if (rank4.length >= 1) {
          picks.push(...pickRandomForDomain(rank4[Math.floor(Math.random() * rank4.length)], 1));
        }

        // (E) If fewer than 8 (pool exhausted), fill from any remaining
        let usedIds = new Set(picks.map(v => v.id));
        while (picks.length < 8) {
          const pool = allVignettes.filter(v => !usedIds.has(v.id));
          if (!pool.length) break;
          shuffle(pool);
          picks.push(pool[0]);
          usedIds.add(pool[0].id);
        }

        // (F) Shuffle the final 8 so display order is random
        shuffle(picks);
        window.block4Vignettes = picks;
      }

      // ─────────────────────────────────────────────────────────────────────
      // 5) RETRIEVE OR INITIALIZE ANSWERS (memory only)
      //    window.block4Answers = { vignetteID: { novelty: "Yes"/"No"/"IDK", confidence: "7", wow: "3" }, … }
      // ─────────────────────────────────────────────────────────────────────
      if (!window.block4Answers) {
        window.block4Answers = {};
      }

      // ─────────────────────────────────────────────────────────────────────
      // 6) RENDER THE 8 VIGNETTES INTO #vignette-container
      // ─────────────────────────────────────────────────────────────────────
      const container = document.getElementById('vignette-container');
      container.innerHTML = ''; // clear any prior content

      window.block4Vignettes.forEach((vig, idx) => {
        // Outer row: a flex container with three columns: Novel? / Confidence / Wow
        const row = document.createElement('div');
        row.className = 'block-4-row';

        // ───────── Novel? Column ─────────
        const novelGroup = document.createElement('div');
        novelGroup.className = 'novel-group';

        // Label above the three circle‐radios
        const novelLabel = document.createElement('div');
        novelLabel.className = 'group-label';
        novelLabel.textContent = `Vignette ${idx + 1}:`;
        novelGroup.appendChild(novelLabel);

        // Three options: Yes / No / I don’t know
        ['Yes','No',"I don’t know"].forEach(option => {
          const optDiv = document.createElement('div');
          optDiv.className = 'novel-option';

          // Hidden radio input
          const input = document.createElement('input');
          input.type = 'radio';
          input.className = 'novel-radio';
          input.name = `${vig.id}-novelty`;
          input.id = `${vig.id}-novelty-${option.replace(/\s+/g,'')}`;
          input.value = option;

          // Restore if previously chosen
          const savedObj = window.block4Answers[vig.id];
          if (savedObj && savedObj.novelty === option) {
            input.checked = true;
          }

          // On change, save into memory
          input.addEventListener('change', () => {
            if (!window.block4Answers[vig.id]) window.block4Answers[vig.id] = {};
            window.block4Answers[vig.id].novelty = option;
          });

          // The circle label
          const circle = document.createElement('label');
          circle.className = 'novel-circle';
          circle.setAttribute('for', input.id);

          // The text next to the circle
          const text = document.createElement('div');
          text.className = 'novel-text';
          text.textContent = option;

          optDiv.appendChild(input);
          optDiv.appendChild(circle);
          optDiv.appendChild(text);
          novelGroup.appendChild(optDiv);
        });

        // ───────── Confidence Column ─────────
        const confGroup = document.createElement('div');
        confGroup.className = 'confidence-group';

        // Header: “Confidence: X/10”
        const confHeader = document.createElement('div');
        confHeader.className = 'group-header';
        const confLabel = document.createElement('div');
        confLabel.className = 'group-label';
        confLabel.textContent = 'Confidence:';
        const confVal = document.createElement('div');
        confVal.className = 'slider-value';
        confVal.id = `${vig.id}-confidence-val`;
        confVal.textContent = window.block4Answers[vig.id]?.confidence || '0';
        const confMax = document.createElement('div');
        confMax.className = 'slider-max';
        confMax.textContent = '/10';

        confHeader.appendChild(confLabel);
        confHeader.appendChild(confVal);
        confHeader.appendChild(confMax);
        confGroup.appendChild(confHeader);

        // Slider input
        const confWrapper = document.createElement('div');
        confWrapper.className = 'slider-wrapper';
        const confInput = document.createElement('input');
        confInput.type = 'range';
        confInput.className = 'slider-input';
        confInput.id = `${vig.id}-confidence`;
        confInput.name = `${vig.id}-confidence`;
        confInput.min = '0';
        confInput.max = '10';
        confInput.step = '1';
        // Restore value or default 0
        if (window.block4Answers[vig.id]?.confidence) {
          confInput.value = window.block4Answers[vig.id].confidence;
        } else {
          confInput.value = '0';
        }
        // Initialize CSS fill
        confInput.style.setProperty('--slider-fill', `${(confInput.value / 10) * 100}%`);

        // On input, update the value display and memory, and update CSS fill
        confInput.addEventListener('input', () => {
          const v = confInput.value;
          confVal.textContent = v;
          confInput.style.setProperty('--slider-fill', `${(v / 10) * 100}%`);
          if (!window.block4Answers[vig.id]) window.block4Answers[vig.id] = {};
          window.block4Answers[vig.id].confidence = v;
        });

        confWrapper.appendChild(confInput);
        confGroup.appendChild(confWrapper);

        // ───────── Wow Column ─────────
        const wowGroup = document.createElement('div');
        wowGroup.className = 'wow-group';

        const wowHeader = document.createElement('div');
        wowHeader.className = 'group-header';
        const wowLabel = document.createElement('div');
        wowLabel.className = 'group-label';
        wowLabel.textContent = '“Wow” factor:';
        const wowVal = document.createElement('div');
        wowVal.className = 'slider-value';
        wowVal.id = `${vig.id}-wow-val`;
        wowVal.textContent = window.block4Answers[vig.id]?.wow || '0';
        const wowMax = document.createElement('div');
        wowMax.className = 'slider-max';
        wowMax.textContent = '/10';

        wowHeader.appendChild(wowLabel);
        wowHeader.appendChild(wowVal);
        wowHeader.appendChild(wowMax);
        wowGroup.appendChild(wowHeader);

        const wowWrapper = document.createElement('div');
        wowWrapper.className = 'slider-wrapper';
        const wowInput = document.createElement('input');
        wowInput.type = 'range';
        wowInput.className = 'slider-input';
        wowInput.id = `${vig.id}-wow`;
        wowInput.name = `${vig.id}-wow`;
        wowInput.min = '0';
        wowInput.max = '10';
        wowInput.step = '1';
        if (window.block4Answers[vig.id]?.wow) {
          wowInput.value = window.block4Answers[vig.id].wow;
        } else {
          wowInput.value = '0';
        }
        wowInput.style.setProperty('--slider-fill', `${(wowInput.value / 10) * 100}%`);

        wowInput.addEventListener('input', () => {
          const v = wowInput.value;
          wowVal.textContent = v;
          wowInput.style.setProperty('--slider-fill', `${(v / 10) * 100}%`);
          if (!window.block4Answers[vig.id]) window.block4Answers[vig.id] = {};
          window.block4Answers[vig.id].wow = v;
        });

        wowWrapper.appendChild(wowInput);
        wowGroup.appendChild(wowWrapper);

        // ───────── Assemble the row ─────────
        row.appendChild(novelGroup);
        row.appendChild(confGroup);
        row.appendChild(wowGroup);

        // Attach the vignette’s descriptive text above the row
        const textPara = document.createElement('p');
        textPara.className = 'vignette-text';
        textPara.innerHTML = `<strong>Vignette ${idx + 1}:</strong> ${vig.text}`;

        container.appendChild(textPara);
        container.appendChild(row);
      });
    })();
  </script>
</section>
