<!-- File: blocks/block4-scaling.html -->
<section id="block4" class="survey-block">
  <h2>Rate The Novelty</h2>
  <p class="prompt">
    You will now see <strong>8</strong> short vignettes. For each one:
    <ul>
      <li>“Would you consider this metabolite truly novel?” – <em>Yes</em> / <em>No</em> / <em>I don’t know</em></li>
      <li>“How confident are you in that judgment?” (0 = not confident, 10 = completely sure)</li>
      <li>“Rate its ‘Wow’ factor” (0 = not impressive, 10 = extremely impressive)</li>
    </ul>
  </p>

  <!-- This is where the script will insert eight vignette rows -->
  <div id="vignette-container"></div>

  <div class="nav-buttons">
    <button class="prev-btn">Back</button>
    <button class="next-btn">Next</button>
  </div>

  <!-- ───────────────────────────────────────────────────────────────────
       SCRIPT: 
         1) Reads Block 3’s domain‐rank answers from window.block3DomainAnswers,
         2) Picks exactly 8 vignettes (4 from Rank 1, 2 from Rank 2, 1 from Rank 3, 1 from Rank 4),
         3) Displays each with its category image (from survey/img/<Domain>/<ID>.png),
            plus the three “Yes/No/I don’t know” circle‐radios and two sliders,
         4) Preserves answers in window.block4Answers (in‐memory) so Back/Next does not clear them.
     ─────────────────────────────────────────────────────────────────── -->
  <script>
    (function() {
      // ─────────────────────────────────────────────────────────────────────
      // 1) DEFINE ALL VIGNETTES WITH domain & text (and ID)
      //    Replace “text” with your actual vignette descriptions.
      //    Make sure each image file matches the ID and sits in /img/<Domain>/<ID>.png
      // ─────────────────────────────────────────────────────────────────────
      const allVignettes = [
        // Structural / Scaffold novelty
        { id: 'S_vig1', domain: 'Structural', text: 'A metabolite bearing a fused tetracyclic core never reported in any bacterial species.' },
        { id: 'S_vig2', domain: 'Structural', text: 'A linear peptide chain containing selenium and boron linkages in its backbone.' },
        { id: 'S_vig3', domain: 'Structural', text: 'A macrocyclic scaffold with an unprecedented 14‐membered ring.' },
        { id: 'S_vig4', domain: 'Structural', text: 'A hybrid scaffold linking two classic alkaloid rings via an ether bridge.' },
        { id: 'S_vig5', domain: 'Structural', text: 'A highly strained bicyclic molecule that spontaneously rearranges under mild conditions.' },

        // Biosynthetic / Catalytic novelty
        { id: 'B_vig1', domain: 'Biosynthetic', text: 'An enzyme with a new fold catalyzing a rearrangement never seen in nature.' },
        { id: 'B_vig2', domain: 'Biosynthetic', text: 'Biosynthesis that uses FAD‐dependent radical chemistry on a sugar moiety.' },
        { id: 'B_vig3', domain: 'Biosynthetic', text: 'Convergent co‐expression of two unrelated pathways to yield a single hybrid product.' },
        { id: 'B_vig4', domain: 'Biosynthetic', text: 'A known oxidase scaffold repurposed to install a nitrile in one step.' },

        // Functional / Phenotypic novelty
        { id: 'F_vig1', domain: 'Functional', text: 'Potent activity against a pathogen with a novel mode of action never reported.' },
        { id: 'F_vig2', domain: 'Functional', text: 'Dual activity as both an anticancer agent and a microbial signaling molecule.' },
        { id: 'F_vig3', domain: 'Functional', text: 'Selective inhibition of a drug‐resistant strain through an unexplored target.' },

        // Evolutionary / Ecological novelty
        { id: 'E_vig1', domain: 'Evolutionary', text: 'Produced only by a deep‐sea fungus previously thought incapable of secondary metabolism.' },
        { id: 'E_vig2', domain: 'Evolutionary', text: 'A known soil metabolite now found in an Antarctic microbe—first marine convergence.' },
        { id: 'E_vig3', domain: 'Evolutionary', text: 'Gene cluster suggests horizontal transfer from a plant lineage into bacteria.' }
      ];

      // ─────────────────────────────────────────────────────────────────────
      // 2) SHUFFLE UTILITY (Fisher–Yates, in‐place)
      // ─────────────────────────────────────────────────────────────────────
      function shuffle(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
      }

      // ─────────────────────────────────────────────────────────────────────
      // 3) READ BLOCK 3 DOMAINS AND GROUP BY RANK
      //    Expect window.block3DomainAnswers = { Structural: "1", … }
      //    If missing/invalid, default that domain to rank 4.
      // ─────────────────────────────────────────────────────────────────────
      const domainRanks = window.block3DomainAnswers || {};
      const rankToDomains = { 1: [], 2: [], 3: [], 4: [] };
      ['Structural', 'Biosynthetic', 'Functional', 'Evolutionary'].forEach(dom => {
        const r = parseInt(domainRanks[dom] || '5', 10);
        if (r >= 1 && r <= 4) {
          rankToDomains[r].push(dom);
        } else {
          rankToDomains[4].push(dom);
        }
      });

      // ─────────────────────────────────────────────────────────────────────
      // 4) PICK 8 VIGNETTES BASED ON RANK TIERS, THEN SHUFFLE THE FINAL 8
      //    Rank 1:  4 picks
      //    Rank 2:  2 picks
      //    Rank 3:  1 pick
      //    Rank 4:  1 pick
      //    If fewer available in a tier, adjust as needed (e.g. split among multiple domains).
      //    Once 8 are chosen, shuffle for random display order.
      //    Store in window.block4Vignettes so it persists across Next/Back.
      // ─────────────────────────────────────────────────────────────────────
      if (!window.block4Vignettes) {
        const picks = [];

        function pickRandomForDomain(domain, count) {
          const pool = allVignettes.filter(v => v.domain === domain);
          if (pool.length <= count) return pool.slice();
          shuffle(pool);
          return pool.slice(0, count);
        }

        // Rank 1 → 4 picks
        const rank1 = rankToDomains[1];
        if (rank1.length === 1) {
          picks.push(...pickRandomForDomain(rank1[0], 4));
        } else if (rank1.length === 2) {
          picks.push(...pickRandomForDomain(rank1[0], 2));
          picks.push(...pickRandomForDomain(rank1[1], 2));
        } else if (rank1.length >= 3) {
          const chosen = rank1.slice();
          shuffle(chosen);
          // Pick one each from first three, plus one more from the fourth (wrap if only 3).
          picks.push(...pickRandomForDomain(chosen[0], 1));
          picks.push(...pickRandomForDomain(chosen[1], 1));
          picks.push(...pickRandomForDomain(chosen[2], 1));
          picks.push(...pickRandomForDomain(chosen[3 % chosen.length], 1));
        }

        // Rank 2 → 2 picks
        const rank2 = rankToDomains[2];
        if (rank2.length === 1) {
          picks.push(...pickRandomForDomain(rank2[0], 2));
        } else if (rank2.length === 2) {
          picks.push(...pickRandomForDomain(rank2[0], 1));
          picks.push(...pickRandomForDomain(rank2[1], 1));
        } else if (rank2.length >= 3) {
          shuffle(rank2);
          picks.push(...pickRandomForDomain(rank2[0], 1));
          picks.push(...pickRandomForDomain(rank2[1], 1));
        }

        // Rank 3 → 1 pick
        const rank3 = rankToDomains[3];
        if (rank3.length >= 1) {
          const choice = rank3[Math.floor(Math.random() * rank3.length)];
          picks.push(...pickRandomForDomain(choice, 1));
        }

        // Rank 4 → 1 pick
        const rank4 = rankToDomains[4];
        if (rank4.length >= 1) {
          const choice = rank4[Math.floor(Math.random() * rank4.length)];
          picks.push(...pickRandomForDomain(choice, 1));
        }

        // If fewer than 8 (pool ran out), fill from any remaining unpicked vignettes
        let usedIds = new Set(picks.map(v => v.id));
        while (picks.length < 8) {
          const pool = allVignettes.filter(v => !usedIds.has(v.id));
          if (!pool.length) break;
          shuffle(pool);
          picks.push(pool[0]);
          usedIds.add(pool[0].id);
        }

        // Finally, shuffle the 8 picks so display order is random
        shuffle(picks);
        window.block4Vignettes = picks;
      }

      // ─────────────────────────────────────────────────────────────────────
      // 5) INITIALIZE OR RETRIEVE ANSWERS OBJECT
      //    window.block4Answers = { <vignetteID>: { novelty: "Yes"/"No"/"IDK", 
      //                                             confidence: "7", wow: "3" }, … }
      // ─────────────────────────────────────────────────────────────────────
      if (!window.block4Answers) {
        window.block4Answers = {};
      }

      // ─────────────────────────────────────────────────────────────────────
      // 6) RENDER THE VIGNETTES
      //    For each picking (window.block4Vignettes), we:
      //      - Insert a <p class="vignette-label"><strong>N.</strong> Is this novel?</p>
      //      - Insert a <div class="block-4-row"> with three columns:
      //           [Column 1] <div class="image-col"><img … ></div>
      //           [Column 2] <div class="novel-group"> three circle‐radios </div>
      //           [Column 3] <div class="slider-col"> two sliders (confidence + wow) </div>
      //    Each radio/slider uses window.block4Answers to restore any previous value.
      // ─────────────────────────────────────────────────────────────────────
      const container = document.getElementById('vignette-container');
      container.innerHTML = ''; // clear any old content

      window.block4Vignettes.forEach((vig, idx) => {
        // ───────────────────────────────────────────────────────────────
        // 6A) LINE ABOVE ROW: “N. Is this novel?”
        // ───────────────────────────────────────────────────────────────
        const labelLine = document.createElement('p');
        labelLine.className = 'vignette-label';
        labelLine.innerHTML = `<strong>${idx + 1}.</strong> Is this novel?`;
        container.appendChild(labelLine);

        // ───────────────────────────────────────────────────────────────
        // 6B) CREATE THE FLEX ROW WRAPPER
        // ───────────────────────────────────────────────────────────────
        const row = document.createElement('div');
        row.className = 'block-4-row';

        // ───────── [Column 1] IMAGE: load from survey/img/<Domain>/<ID>.png ─────────
        const imgCol = document.createElement('div');
        imgCol.className = 'image-col';
        const img = document.createElement('img');
        img.className = 'vignette-img';
        // ASSUME your images are in survey/img/<Domain>/<ID>.png
        // If your files are .jpg or .jpeg, adjust the extension accordingly.
        img.src = `img/${vig.domain}/${vig.id}.png`;
        img.alt = `Vignette ${idx + 1} illustration`;
        // Force 100×100 px (you can also override via CSS if needed)
        img.width = 100;
        img.height = 100;
        imgCol.appendChild(img);
        row.appendChild(imgCol);

        // ───────── [Column 2] NOVEL? three circle-radios ─────────
        const novelCol = document.createElement('div');
        novelCol.className = 'novel-group';

        ['Yes','No',"I don’t know"].forEach(option => {
          const optDiv = document.createElement('div');
          optDiv.className = 'novel-option';

          const input = document.createElement('input');
          input.type = 'radio';
          input.className = 'novel-radio';
          input.name = `${vig.id}-novelty`;
          input.id = `${vig.id}-novelty-${option.replace(/\s+/g,'')}`;
          input.value = option;
          // Restore if previously chosen
          const savedObj = window.block4Answers[vig.id];
          if (savedObj && savedObj.novelty === option) {
            input.checked = true;
          }
          input.addEventListener('change', () => {
            if (!window.block4Answers[vig.id]) window.block4Answers[vig.id] = {};
            window.block4Answers[vig.id].novelty = option;
          });

          const circle = document.createElement('label');
          circle.className = 'novel-circle';
          circle.setAttribute('for', input.id);

          const text = document.createElement('div');
          text.className = 'novel-text';
          text.textContent = option;

          optDiv.appendChild(input);
          optDiv.appendChild(circle);
          optDiv.appendChild(text);
          novelCol.appendChild(optDiv);
        });

        row.appendChild(novelCol);

        // ───────── [Column 3] TWO SLIDERS: “Confidence” + “Wow” ─────────
        const sliderCol = document.createElement('div');
        sliderCol.className = 'slider-col';

        // (1) Confidence slider group
        const confWrapper = document.createElement('div');
        confWrapper.className = 'confidence-group';

        const confHeader = document.createElement('div');
        confHeader.className = 'group-header';
        const confLabel = document.createElement('div');
        confLabel.className = 'group-label';
        confLabel.textContent = 'Confidence:';
        const confVal = document.createElement('div');
        confVal.className = 'slider-value';
        confVal.id = `${vig.id}-confidence-val`;
        confVal.textContent = window.block4Answers[vig.id]?.confidence || '0';
        const confMax = document.createElement('div');
        confMax.className = 'slider-max';
        confMax.textContent = '/10';

        confHeader.appendChild(confLabel);
        confHeader.appendChild(confVal);
        confHeader.appendChild(confMax);

        const confInputWrapper = document.createElement('div');
        confInputWrapper.className = 'slider-wrapper';
        const confInput = document.createElement('input');
        confInput.type = 'range';
        confInput.className = 'slider-input';
        confInput.id = `${vig.id}-confidence`;
        confInput.name = `${vig.id}-confidence`;
        confInput.min = '0';
        confInput.max = '10';
        confInput.step = '1';
        if (window.block4Answers[vig.id]?.confidence) {
          confInput.value = window.block4Answers[vig.id].confidence;
        } else {
          confInput.value = '0';
        }
        // Initialize the CSS fill for blue track
        confInput.style.setProperty('--slider-fill', `${(confInput.value / 10) * 100}%`);

        confInput.addEventListener('input', () => {
          const v = confInput.value;
          confVal.textContent = v;
          confInput.style.setProperty('--slider-fill', `${(v / 10) * 100}%`);
          if (!window.block4Answers[vig.id]) window.block4Answers[vig.id] = {};
          window.block4Answers[vig.id].confidence = v;
        });

        confInputWrapper.appendChild(confInput);
        confWrapper.appendChild(confHeader);
        confWrapper.appendChild(confInputWrapper);
        sliderCol.appendChild(confWrapper);

        // (2) “Wow” factor slider group
        const wowWrapper = document.createElement('div');
        wowWrapper.className = 'wow-group';

        const wowHeader = document.createElement('div');
        wowHeader.className = 'group-header';
        const wowLabel = document.createElement('div');
        wowLabel.className = 'group-label';
        wowLabel.textContent = '“Wow” factor:';
        const wowVal = document.createElement('div');
        wowVal.className = 'slider-value';
        wowVal.id = `${vig.id}-wow-val`;
        wowVal.textContent = window.block4Answers[vig.id]?.wow || '0';
        const wowMax = document.createElement('div');
        wowMax.className = 'slider-max';
        wowMax.textContent = '/10';

        wowHeader.appendChild(wowLabel);
        wowHeader.appendChild(wowVal);
        wowHeader.appendChild(wowMax);

        const wowInputWrapper = document.createElement('div');
        wowInputWrapper.className = 'slider-wrapper';
        const wowInput = document.createElement('input');
        wowInput.type = 'range';
        wowInput.className = 'slider-input';
        wowInput.id = `${vig.id}-wow`;
        wowInput.name = `${vig.id}-wow`;
        wowInput.min = '0';
        wowInput.max = '10';
        wowInput.step = '1';
        if (window.block4Answers[vig.id]?.wow) {
          wowInput.value = window.block4Answers[vig.id].wow;
        } else {
          wowInput.value = '0';
        }
        wowInput.style.setProperty('--slider-fill', `${(wowInput.value / 10) * 100}%`);

        wowInput.addEventListener('input', () => {
          const v = wowInput.value;
          wowVal.textContent = v;
          wowInput.style.setProperty('--slider-fill', `${(v / 10) * 100}%`);
          if (!window.block4Answers[vig.id]) window.block4Answers[vig.id] = {};
          window.block4Answers[vig.id].wow = v;
        });

        wowInputWrapper.appendChild(wowInput);
        wowWrapper.appendChild(wowHeader);
        wowWrapper.appendChild(wowInputWrapper);
        sliderCol.appendChild(wowWrapper);

        row.appendChild(sliderCol);

        // ───────────────────────────────────────────────────────────────
        // 6C) APPEND THE COMPLETED ROW TO THE CONTAINER
        // ───────────────────────────────────────────────────────────────
        container.appendChild(row);
      });
    })();
  </script>
</section>
