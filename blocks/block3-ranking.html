<!-- Block 3: Vignette Ranking -->
<section class="survey-block" id="block3" data-type="ranking">
  <h2>Block 3 – Vignette Ranking</h2>
  <p class="prompt">
    Click on a vignette to assign it the next available rank (1 → 2 → 3 → …).  
    Once all have a number, you can still drag the little “handle” (⋮⋮) to re‐order and adjust.
  </p>

  <!-- scrollable container for long lists -->
  <div class="ranking-wrapper">
    <ul id="rankingList" class="ranking-list">
      <!--
        Each <li> must have:
        • data-value="v#"   (any unique ID you use later for submission)
        • draggable="true"   (for the drag‐handle to work)
      -->
      <li data-value="v1" draggable="true">
        <span class="rank-number"></span>
        <span class="item-text">
          Vignette 1: Lorem ipsum dolor sit amet…
        </span>
        <span class="drag-handle" title="Drag to reorder">⋮⋮</span>
      </li>
      <li data-value="v2" draggable="true">
        <span class="rank-number"></span>
        <span class="item-text">
          Vignette 2: Consectetur adipiscing elit…
        </span>
        <span class="drag-handle" title="Drag to reorder">⋮⋮</span>
      </li>
      <li data-value="v3" draggable="true">
        <span class="rank-number"></span>
        <span class="item-text">
          Vignette 3: Sed do eiusmod tempor…
        </span>
        <span class="drag-handle" title="Drag to reorder">⋮⋮</span>
      </li>
      <li data-value="v4" draggable="true">
        <span class="rank-number"></span>
        <span class="item-text">
          Vignette 4: Incididunt ut labore et dolore…
        </span>
        <span class="drag-handle" title="Drag to reorder">⋮⋮</span>
      </li>
      <li data-value="v5" draggable="true">
        <span class="rank-number"></span>
        <span class="item-text">
          Vignette 5: Magna aliqua…
        </span>
        <span class="drag-handle" title="Drag to reorder">⋮⋮</span>
      </li>
    </ul>
  </div>

  <!-- Hidden input to capture final order as CSV: v3,v1,v5,… -->
  <input type="hidden" name="vignetteRanking" id="vignetteRanking" value="">

  <div class="navigation">
    <button class="prev-btn">Back</button>
    <!-- Disabled until every item has a rank assigned -->
    <button class="next-btn" id="submitRanking" disabled>Next</button>
  </div>
</section>

<!-- Inline script for “click to rank” + drag/drop → updates #vignetteRanking -->
<script>
  (function() {
    const list = document.getElementById('rankingList');
    const hiddenInput = document.getElementById('vignetteRanking');
    const nextBtn     = document.getElementById('submitRanking');
    let nextRank = 1;

    // 1) CLICK‐TO‐ASSIGN logic
    list.addEventListener('click', (e) => {
      const li = e.target.closest('li');
      if (!li) return;
      // If this <li> already has a rank, ignore
      if (li.getAttribute('data-rank')) return;

      // Assign nextRank, then increment
      li.setAttribute('data-rank', nextRank);
      nextRank++;

      // After assigning, reorganize list:
      //   • First come all items with a data-rank (in ascending order of that number)
      //   • Then come all items without a data-rank (in original order)
      const rankedItems   = Array.from(list.children)
        .filter(item => item.hasAttribute('data-rank'))
        .sort((a, b) => +a.getAttribute('data-rank') - +b.getAttribute('data-rank'));

      const unrankedItems = Array.from(list.children)
        .filter(item => !item.hasAttribute('data-rank'));

      // Clear and re‐append
      list.innerHTML = '';
      rankedItems.forEach(item => list.appendChild(item));
      unrankedItems.forEach(item => list.appendChild(item));

      // Update the visible “rank‐number” badges
      updateVisualRanks();

      // If all items are now ranked, enable “Next”
      if (unrankedItems.length === 0) {
        nextBtn.disabled = false;
      }

      // Sync hidden input
      updateHiddenInput();
    });

    // 2) DRAG‐AND‐DROP logic (reassign data-rank after drop)
    let dragSrcEl = null;

    function handleDragStart(e) {
      dragSrcEl = this;
      this.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', '');
    }

    function handleDragOver(e) {
      e.preventDefault();
      const target = e.target.closest('li');
      if (!target || target === dragSrcEl) return;

      const rect = target.getBoundingClientRect();
      const halfway = (rect.bottom - rect.top) / 2;
      const afterTarget = (e.clientY - rect.top) > halfway;
      // Insert the dragged element before or after target
      list.insertBefore(dragSrcEl, afterTarget ? target.nextSibling : target);
    }

    function handleDragEnd() {
      this.classList.remove('dragging');
      reassignRanksAfterDrag();
      updateHiddenInput();
    }

    // After a drag‐drop, we want to recalculate “data-rank” to match the new visual order
    function reassignRanksAfterDrag() {
      // Items that already had a rank keep their relative positions,
      // but we will renumber everything from top to bottom to be contiguous 1→N.
      const allItems = Array.from(list.children);
      allItems.forEach((li, idx) => {
        li.setAttribute('data-rank', idx + 1);
      });
      nextRank = allItems.length + 1; // so no “unranked” remain
      updateVisualRanks();
    }

    // Utility: update the <span class="rank-number"> inside each <li>
    function updateVisualRanks() {
      Array.from(list.children).forEach((li, idx) => {
        const badge = li.querySelector('.rank-number');
        const rank = li.getAttribute('data-rank') || '';
        badge.textContent = rank;
      });
    }

    // Utility: write out the hidden CSV of data-value in the current order
    function updateHiddenInput() {
      const values = Array.from(list.children)
        .map(li => li.getAttribute('data-value'));
      hiddenInput.value = values.join(',');
    }

    // Attach drag listeners to each <li>
    document.querySelectorAll('#rankingList
