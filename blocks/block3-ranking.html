<!-- Block 3: Vignette Ranking -->
<section class="survey-block" id="block3" data-type="ranking">
  <h2>Block 3 – Vignette Ranking</h2>
  <p class="prompt">
    Use the dropdown on the left to assign each vignette a rank (1 → 2 → 3 …).  
    You can also drag the “⋮⋮” handle if you want to reorder manually.
  </p>

  <!-- 
    Wrapping DIV makes the <ul> scrollable if you have lots of vignettes.
    The CSS below caps its height—scrollbars appear past ~6–7 items. 
  -->
  <div class="ranking-wrapper">
    <ul id="rankingList" class="ranking-list">
      <!--
        Copy/paste or edit these <li> blocks to match your actual vignette text.
        Important attributes on each <li>:
          • data-value="v1"  → unique ID for this vignette (used in hidden input).
          • draggable="true" → enables the drag-and-drop handle.
      -->
      <li data-value="v1" draggable="true">
        <span class="order-select">
          <!-- placeholder; JS will populate the <select> with 1…N later -->
          <select></select>
        </span>
        <span class="item-text">
          Vignette 1: Lorem ipsum dolor sit amet…
        </span>
        <span class="drag-handle" title="Drag to reorder">⋮⋮</span>
      </li>

      <li data-value="v2" draggable="true">
        <span class="order-select">
          <select></select>
        </span>
        <span class="item-text">
          Vignette 2: Consectetur adipiscing elit…
        </span>
        <span class="drag-handle" title="Drag to reorder">⋮⋮</span>
      </li>

      <li data-value="v3" draggable="true">
        <span class="order-select">
          <select></select>
        </span>
        <span class="item-text">
          Vignette 3: Sed do eiusmod tempor…
        </span>
        <span class="drag-handle" title="Drag to reorder">⋮⋮</span>
      </li>

      <li data-value="v4" draggable="true">
        <span class="order-select">
          <select></select>
        </span>
        <span class="item-text">
          Vignette 4: Incididunt ut labore et dolore…
        </span>
        <span class="drag-handle" title="Drag to reorder">⋮⋮</span>
      </li>

      <li data-value="v5" draggable="true">
        <span class="order-select">
          <select></select>
        </span>
        <span class="item-text">
          Vignette 5: Magna aliqua…
        </span>
        <span class="drag-handle" title="Drag to reorder">⋮⋮</span>
      </li>
    </ul>
  </div>

  <!-- Hidden field to store final order as “v3,v1,v5,…”. Send this on Next. -->
  <input type="hidden" name="vignetteRanking" id="vignetteRanking" value="">

  <div class="navigation">
    <button class="prev-btn">Back</button>
    <button class="next-btn" id="submitRanking" disabled>Next</button>
  </div>
</section>

<!--
  Inline <script> to:
   1. Populate each <select> with options “1…N” and default its value to the item’s index + 1.
   2. On dropdown‐change, reinsert that <li> at the new position and re-label all selects.
   3. Allow drag‐and‐drop by the “⋮⋮” handle, and renumber selects on drop.
   4. Maintain hidden #vignetteRanking.value = CSV of data-value in visual order.
-->
<script>
  (function() {
    const list = document.getElementById('rankingList');
    const hiddenInput = document.getElementById('vignetteRanking');
    const nextBtn = document.getElementById('submitRanking');

    // 1) On load, build the <select> for each <li> based on total items N:
    function initSelects() {
      const items = Array.from(list.children);
      const N = items.length;

      items.forEach((li, idx) => {
        const select = li.querySelector('select');
        select.innerHTML = ''; // clear placeholder

        // Add options “1…N”
        for (let i = 1; i <= N; i++) {
          const opt = document.createElement('option');
          opt.value = i;
          opt.textContent = i;
          select.appendChild(opt);
        }
        // Default selected value = current index + 1
        select.value = idx + 1;
      });
      updateHiddenInput();
      // Only enable Next if every <li> has a valid select (always true on load)
      nextBtn.disabled = false;
    }

    // 2) When a dropdown changes, reposition the <li> 
    function handleSelectChange(e) {
      const select = e.target;
      const newRank = parseInt(select.value, 10);
      const li = select.closest('li');

      // Remove this <li> from the <ul>...
      list.removeChild(li);

      // Insert it at index = newRank - 1
      const children = Array.from(list.children);
      if (newRank > children.length) {
        list.appendChild(li);
      } else {
        list.insertBefore(li, children[newRank - 1]);
      }

      // Reassign all selects in visual order
      reassignSelects();
      updateHiddenInput();
    }

    // 3) After drag & drop, reassign select values to match visual order
    function reassignSelects() {
      Array.from(list.children).forEach((li, idx) => {
        const select = li.querySelector('select');
        select.value = idx + 1;
      });
    }

    // 4) Update the hidden CSV: “v2,v4,v1,…”
    function updateHiddenInput() {
      const values = Array.from(list.children).map(li => li.getAttribute('data-value'));
      hiddenInput.value = values.join(',');
    }

    // --- Drag & Drop setup (handle only the six‐dot "⋮⋮" area) --- 
    let dragSrcEl = null;

    function handleDragStart(e) {
      // Only allow dragging if the user clicked on the handle
      if (!e.target.classList.contains('drag-handle')) {
        e.preventDefault();
        return;
      }
      dragSrcEl = this;
      this.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', '');
    }

    function handleDragOver(e) {
      e.preventDefault();
      const targetLi = e.target.closest('li');
      if (!targetLi || targetLi === dragSrcEl) return;

      const rect = targetLi.getBoundingClientRect();
      const halfway = (rect.bottom - rect.top) / 2;
      const afterTarget = (e.clientY - rect.top) > halfway;

      if (afterTarget) {
        list.insertBefore(dragSrcEl, targetLi.nextSibling);
      } else {
        list.insertBefore(dragSrcEl, targetLi);
      }
    }

    function handleDragEnd() {
      this.classList.remove('dragging');
      reassignSelects();  // Renumber selects based on new visual order
      updateHiddenInput();
    }

    // Attach event listeners
    function attachListeners() {
      // 1. Populate and enable selects
      initSelects();
      // 2. Listen for any <select> change
      document.querySelectorAll('#rankingList select').forEach(sel => {
        sel.addEventListener('change', handleSelectChange);
      });
      // 3. Attach drag events to each <li>
      document.querySelectorAll('#rankingList li').forEach(li => {
        li.addEventListener('dragstart', handleDragStart, false);
        li.addEventListener('dragover',  handleDragOver,  false);
        li.addEventListener('dragend',   handleDragEnd,   false);
      });
    }

    // Invoke on DOMContentLoaded (or immediately if this script is at bottom)
    attachListeners();
  })();
</script>
