<!-- File: blocks/block3-ranking.html -->
<section class="survey-block" id="block3" data-type="ranking">
  <!-- ─────────────────────────────────────────────────────────────────
       STAGE 1: Rank the Four Top‐Level Domains
     ───────────────────────────────────────────────────────────────── -->
  <div id="stage1">
    <h2>Block 3 – Domain Prioritization</h2>
    <p class="prompt">
      Please assign a unique rank to each domain (1 = most important, 4 = least important).  
      Type a number (1–4) in the box next to each statement. Do not repeat ranks.
    </p>

    <!-- This is where the four “domain” ranking‐items will be injected -->
    <div id="vignette-list"></div>

    <div class="navigation">
      <button class="prev-btn">Back</button>
      <!-- Notice: no “next-btn” class here, so main.js will not advance to block 4 -->
      <button id="stage1-next">Next</button>
    </div>
  </div>

  <!-- ─────────────────────────────────────────────────────────────────
       STAGE 2: Rank Subcategories of One of the Top 2 Domains
     ───────────────────────────────────────────────────────────────── -->
  <div id="stage2" style="display: none;">
    <h2>Block 3 – Subcategory Prioritization</h2>
    <p class="prompt" id="stage2-prompt">
      <!-- This will be replaced with, for example:
           “Rank the following subcategories of Structural / Scaffold novelty:” -->
    </p>

    <!-- This is where the chosen domain’s subcategories will be injected -->
    <div id="vignette-list-2"></div>

    <div class="navigation">
      <!-- Goes back to Stage 1 -->
      <button id="stage2-back">Back</button>
      <!-- class="next-btn" so clicking this advances to Block 4 -->
      <button class="next-btn">Next</button>
    </div>
  </div>

  <!-- ─────────────────────────────────────────────────────────────────
       Duplicate‐value checker (exactly as in your original)
     ───────────────────────────────────────────────────────────────── -->
  <script>
    function checkDups() {
      const inputs = document.querySelectorAll('#block3 .rank-input');
      const counts = {};

      inputs.forEach(input => {
        const val = input.value.trim();
        // only consider numbers 1–4
        if (!val || !/^[1-4]$/.test(val)) return;
        counts[val] = (counts[val] || 0) + 1;
      });

      inputs.forEach(input => {
        const val = input.value.trim();
        if (val && counts[val] > 1) {
          input.classList.add('duplicate');
        } else {
          input.classList.remove('duplicate');
        }
      });
    }
  </script>

  <!-- ─────────────────────────────────────────────────────────────────
       Stage 1 & Stage 2 Logic (shuffling, rendering, answer persistence)
     ───────────────────────────────────────────────────────────────── -->
  <script>
    (function() {
      // ─────────────────────────────────────────────────────────────────
      // 1) DATA: the four domains + their subcategories
      // ─────────────────────────────────────────────────────────────────
      const domains = [
        {
          id: 'Structural',
          label: 'Structural / Scaffold novelty',
          subs: [
            { id: 'Structural1', text: 'New carbon/heteroatom scaffold' },
            { id: 'Structural2', text: 'Unusual functional group (e.g., N=N=N)' },
            { id: 'Structural3', text: 'Rare stereochemical pattern' },
            { id: 'Structural4', text: 'Presence of “exotic” atoms (e.g., F or Br)' },
            { id: 'Structural5', text: 'Extreme size/complexity related to carbons (ratio C/Hetero)' }
          ]
        },
        {
          id: 'Biosynthetic',
          label: 'Biosynthetic / Catalytic novelty',
          subs: [
            { id: 'Biosynthetic1', text: 'Entirely new enzyme class (e.g. new fold + AA homology low)' },
            { id: 'Biosynthetic2', text: 'Known folds, new catalytic chemistry' },
            { id: 'Biosynthetic3', text: 'Use of uncommon cofactors' },
            { id: 'Biosynthetic4', text: 'Compounds produced by convergence of 2 pathways' }
          ]
        },
        {
          id: 'Functional',
          label: 'Functional / Phenotypic novelty',
          subs: [
            { id: 'Functional1', text: 'New bioactivity spectrum' },
            { id: 'Functional2', text: 'New mode of action for a known target' },
            { id: 'Functional3', text: 'New Ecological role for a taxonomic rank' }
          ]
        },
        {
          id: 'Evolutionary',
          label: 'Evolutionary / Ecological novelty',
          subs: [
            { id: 'Evolutionary1', text: 'Produced by a previously unsuspected taxon' },
            { id: 'Evolutionary2', text: 'Unique to a taxon (signature compound)' },
            { id: 'Evolutionary3', text: 'Horizontal transfer' }
          ]
        }
      ];

      // ─────────────────────────────────────────────────────────────────
      // 2) UTILITY: Fisher–Yates shuffle (in‐place)
      // ─────────────────────────────────────────────────────────────────
      function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
      }

      // ─────────────────────────────────────────────────────────────────
      // 3) GLOBAL VARIABLES IN WINDOW FOR PERSISTENCE (memory only)
      // ─────────────────────────────────────────────────────────────────
      //
      // window.block3DomainOrder  = Array of 4 domain IDs in shuffled order.
      // window.block3DomainAnswers = { DomainID: "1"|"2"|"3"|"4", … } for Stage 1.
      // window.block3SubParent    = ID of the chosen parent domain (randomly from top 2).
      // window.block3SubOrder     = Array of subcategory IDs in shuffled order (for Stage 2).
      // window.block3SubAnswers   = { SubID: "1"|"2"|…, … } for Stage 2.
      //
      // All of these live only in‐memory and vanish on full refresh.
      // ─────────────────────────────────────────────────────────────────

      // Ensure the global objects exist (or create them)
      if (!window.block3DomainOrder) {
        const ids = domains.map(d => d.id);
        shuffle(ids);
        window.block3DomainOrder = ids;
      }
      if (!window.block3DomainAnswers) {
        window.block3DomainAnswers = {};
      }
      // Note: Stage 2 globals will be created only once the user clicks “Next” from Stage 1.

      // References to our two “stages” and their containers
      const stage1Div       = document.getElementById('stage1');
      const stage2Div       = document.getElementById('stage2');
      const domList         = document.getElementById('vignette-list');
      const subList         = document.getElementById('vignette-list-2');
      const stage2Prompt    = document.getElementById('stage2-prompt');

      // ─────────────────────────────────────────────────────────────────
      // 4) FUNCTION: Render Stage 1 (Rank Domains)
      // ─────────────────────────────────────────────────────────────────
      function renderStage1() {
        domList.innerHTML = ''; // clear previous
        window.block3DomainOrder.forEach(domainId => {
          const domObj = domains.find(d => d.id === domainId);

          // Build <div class="ranking-item"> for this domain
          const itemDiv = document.createElement('div');
          itemDiv.className = 'ranking-item';

          // number‐wrapper holding <input> + arrows
          const numWrap = document.createElement('div');
          numWrap.className = 'number-wrapper';

          const input = document.createElement('input');
          input.type = 'number';
          input.name = `rank_${domObj.id}`;
          input.id   = `rank_${domObj.id}`;
          input.className = 'rank-input';
          input.min  = '1';
          input.max  = '4';
          input.required = true;
          input.setAttribute('oninput', 'checkDups()');

          // Restore any previous answer from memory
          const saved = window.block3DomainAnswers[domObj.id];
          if (saved) {
            input.value = saved;
          }

          // On change, save to memory & run duplicate check
          input.addEventListener('input', () => {
            const v = input.value.trim();
            if (/^[1-4]$/.test(v)) {
              window.block3DomainAnswers[domObj.id] = v;
            } else {
              delete window.block3DomainAnswers[domObj.id];
            }
            checkDups();
          });

          const up = document.createElement('div');
          up.className = 'arrow up';
          up.addEventListener('click', () => {
            let val = parseInt(input.value || '0', 10);
            if (val < 4) {
              input.value = val + 1;
              input.dispatchEvent(new Event('input', { bubbles: true }));
            }
          });

          const down = document.createElement('div');
          down.className = 'arrow down';
          down.addEventListener('click', () => {
            let val = parseInt(input.value || '0', 10);
            if (val > 1) {
              input.value = val - 1;
              input.dispatchEvent(new Event('input', { bubbles: true }));
            }
          });

          numWrap.appendChild(input);
          numWrap.appendChild(up);
          numWrap.appendChild(down);

          const label = document.createElement('label');
          label.setAttribute('for', `rank_${domObj.id}`);
          label.innerHTML = `<strong>${domObj.label}</strong>`;

          itemDiv.appendChild(numWrap);
          itemDiv.appendChild(label);
          domList.appendChild(itemDiv);
        });

        // Highlight duplicates right away if they exist
        checkDups();

        // Show Stage 1, hide Stage 2
        stage1Div.style.display = 'block';
        stage2Div.style.display = 'none';
      }

      // ─────────────────────────────────────────────────────────────────
      // 5) FUNCTION: Render Stage 2 (Rank Subcategories)
      // ─────────────────────────────────────────────────────────────────
      function renderStage2() {
        // (A) Figure out the user’s top‐two from Stage 1
        const domainOrder = window.block3DomainOrder;
        const ansObj      = window.block3DomainAnswers;
        // We want to sort domainOrder by the numeric answers the user gave.
        // But if any domain is missing or invalid, treat its rank as Infinity.
        const sorted = [...domainOrder].sort((a, b) => {
          const va = parseInt(ansObj[a] || 'Infinity', 10);
          const vb = parseInt(ansObj[b] || 'Infinity', 10);
          return va - vb;
        });

        const topTwo = sorted.slice(0, 2); // two domain IDs the user ranked #1 and #2

        // (B) If we have not yet chosen a “parent” for Stage 2, pick one randomly
        if (!window.block3SubParent) {
          const choice = topTwo[Math.floor(Math.random() * 2)];
          window.block3SubParent = choice;
        }
        const parentId = window.block3SubParent;
        const parentObj = domains.find(d => d.id === parentId);

        // (C) Update the Stage 2 prompt to mention the chosen parent’s label
        stage2Prompt.innerHTML = `
          Rank the following subcategories of <strong>${parentObj.label}</strong>:
        `;

        // (D) If we don’t have a shuffled sub‐order for this parent yet, build & store it
        if (!window.block3SubOrder) {
          const subIds = parentObj.subs.map(s => s.id);
          shuffle(subIds);
          window.block3SubOrder = subIds;
        }

        // (E) Ensure we have an answers‐object for Stage 2
        if (!window.block3SubAnswers) {
          window.block3SubAnswers = {};
        }

        // (F) Render each subcategory in the saved order
        subList.innerHTML = '';
        window.block3SubOrder.forEach(subId => {
          const subObj = parentObj.subs.find(s => s.id === subId);

          const itemDiv = document.createElement('div');
          itemDiv.className = 'ranking-item';

          const numWrap = document.createElement('div');
          numWrap.className = 'number-wrapper';

          const input = document.createElement('input');
          input.type = 'number';
          input.name = `rank_${subObj.id}`;
          input.id   = `rank_${subObj.id}`;
          input.className = 'rank-input';
          input.min  = '1';
          input.max  = '5';
          input.required = true;
          input.setAttribute('oninput', 'checkDups()');

          // Restore any previously typed answer
          const saved = window.block3SubAnswers[subObj.id];
          if (saved) {
            input.value = saved;
          }

          input.addEventListener('input', () => {
            const v = input.value.trim();
            // We expect ranks from 1..(number of subcats). Let's assume 1..5 max.
            if (/^[1-5]$/.test(v)) {
              window.block3SubAnswers[subObj.id] = v;
            } else {
              delete window.block3SubAnswers[subObj.id];
            }
            checkDups();
          });

          const up = document.createElement('div');
          up.className = 'arrow up';
          up.addEventListener('click', () => {
            let val = parseInt(input.value || '0', 10);
            if (val < parentObj.subs.length) {
              input.value = val + 1;
              input.dispatchEvent(new Event('input', { bubbles: true }));
            }
          });

          const down = document.createElement('div');
          down.className = 'arrow down';
          down.addEventListener('click', () => {
            let val = parseInt(input.value || '0', 10);
            if (val > 1) {
              input.value = val - 1;
              input.dispatchEvent(new Event('input', { bubbles: true }));
            }
          });

          numWrap.appendChild(input);
          numWrap.appendChild(up);
          numWrap.appendChild(down);

          const label = document.createElement('label');
          label.setAttribute('for', `rank_${subObj.id}`);
          label.innerHTML = `<strong>${subObj.text}</strong>`;

          itemDiv.appendChild(numWrap);
          itemDiv.appendChild(label);
          subList.appendChild(itemDiv);
        });

        // Highlight duplicates if any exist
        checkDups();

        // Show Stage 2, hide Stage 1
        stage1Div.style.display = 'none';
        stage2Div.style.display = 'block';
      }

      // ─────────────────────────────────────────────────────────────────
      // 6) BUTTON HANDLERS FOR NAVIGATION INSIDE BLOCK 3
      // ─────────────────────────────────────────────────────────────────
      document.getElementById('stage1-next').addEventListener('click', () => {
        // Before moving to Stage 2, do a final duplicate‐check for Stage 1
        checkDups();
        // Now render Stage 2
        renderStage2();
      });

      document.getElementById('stage2-back').addEventListener('click', () => {
        // Going back to Stage 1: do not clear any answers, just re-render
        renderStage1();
      });

      // ─────────────────────────────────────────────────────────────────
      // 7) INITIAL ENTRY POINT
      //    On first insertion of Block 3: decide which Stage to show
      // ─────────────────────────────────────────────────────────────────
      function initBlock3() {
        // If the user has already done Stage 2 (i.e. block3SubParent exists),
        // jump to Stage 2 directly. Otherwise start at Stage 1.
        if (window.block3SubParent) {
          renderStage2();
        } else {
          renderStage1();
        }
      }

      // Run it!
      initBlock3();
    })();
  </script>
</section>
